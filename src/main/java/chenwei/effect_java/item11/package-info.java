/**
 * @author chenwei
 *
 */
package chenwei.effect_java.item11;

// 1 重写equals方法时同时也要重写hashcode方法

// 1.1 Object 规范
// 1.1.1 如果两个对象根据equals(Object)方法比较是相等的，那么在两个对象上调用hashCode就必须产生的结果是相同的整数。
// 1.1.2 如果两个对象根据equals(Object)方法比较并不相等，则不要求在每个对象上调用hashCode都必须产生不同的结果。 
// 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables）的性能。

// 1.2 hashCode实现
// 1.2.1 声明一个 int 类型的变量result，并将其初始化为对象中第一个重要属性c的哈希码，
// 如下面步骤2.a中所计算的那样。（回顾条目10，重要的属性是影响比较相等的领域。）
// 1.2.2 对于对象中剩余的重要属性f，请执行以下操作：
// a. 比较属性f与属性c的 int 类型的哈希码：
// -- i. 如果这个属性是基本类型的，使用 Type.hashCode(f)方法计算，其中Type类是对应属性 f 基本类型的包装类。
// -- ii 如果该属性是一个对象引用，并且该类的equals方法通过递归调用equals来比较该属性，并递归地调用hashCode方法。 如果需要更复杂的比较，则计算此字段的“范式（“canonical representation）”，并在范式上调用hashCode。 如果该字段的值为空，则使用0（也可以使用其他常数，但通常来使用0表示）。
// -- iii 如果属性f是一个数组，把它看作每个重要的元素都是一个独立的属性。 也就是说，通过递归地应用这些规则计算每个重要元素的哈希码，并且将每个步骤2.b的值合并。 如果数组没有重要的元素，则使用一个常量，最好不要为0。如果所有元素都很重要，则使用Arrays.hashCode方法。
// b. 将步骤2.a中属性c计算出的哈希码合并为如下结果：result = 31 * result + c;

// 1.3 注意
// 1.3.1 不要试图从哈希码计算中排除重要的属性来提高性能。
// 1.3.2 不要为hashCode返回的值提供详细的规范，因此客户端不能合理地依赖它； 你可以改变它的灵活性。